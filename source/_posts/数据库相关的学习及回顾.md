---
title: Mysql数据库相关的学习及回顾
date: 2020-04-09 20:58:19
tags: 学习笔记·Mysql
---
## 写在前面
对大学课程《数据库原理与应用MySQL》的综合实验的回顾与总结，以及后续数据库学习中的知识点的摘记。  
<!-- more -->

## 数据库设计的流程  
1. 需求分析  
包括：  
    - 信息要求  
    - 处理要求 
    - 系统要求
        - 安全性要求
        - 使用方式要求
        - 可扩充性要求

2. 概念结构设计  
将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程。（这一步中可做出E-R图）  
E-R图：方形表示实体，椭圆形表示实体的属性，实体间的菱形表示实体间的联系（联系有1-1[一对一]，1-m[一对多]，m-n[多对多]三种形式）。  

3. 逻辑结构设计  
将E-R图拆分为数据库的表（实体和联系都对应一张表）。  
拆分出表之后，调整为第三范式。  
同时也可以对视图进行设计。  

4. 物理设计  
分析数据库中已有的索引，考虑需要增加索引的字段有哪些。  

5. 数据库的实现  
创建库、表、用户、触发器和存储过程等。

## 数据库常用技术  
1. [LEFT]JOIN …… on [条件]

2. GROUP BY  

3. 事务的四大特性：ACID  
    - 原子性（Atomic）
    - 一致性（Consistency）
    - 隔离性（Isolation）
    - 持久性（Durability）

4. 事务的隔离级别  
    - Read uncommitted
    - Read Committed  
    - Repeatable Reads
    - Serializable  

5. 乐观锁  
不是真正在数据库中添加锁（真正添加的锁为悲观锁）。是在数据查询时，添加另一个数据为参考，看数据是否发生了变化，如果发生了变化，则表示发生了冲突，则可做出相应的处理。 

6. 密集索引和稀疏索引的区别  
密集索引将索引和叶子节点的信息（整行数据）保存在一个文件中，按照索引的B+树找到叶子节点时，即可获得整行数据。稀疏索引则将内容和索引分开在两个文件中，在索引文件中（稀疏索引的B+树）找到叶子节点中的节点信息（主键信息）后，在另一个主键B+树中查找对应的叶子节点中存放的数据库内容。  
密集索引以空间为代价，可以提高存取效率；稀疏索引则所占空间较小。  
网上说法不一：~~聚簇索引是稀疏索引，数据页上一级索引存储是页指针，非行指针。非聚簇索引是密集索引，在数据页的上一级索引页它为每一个数据行存储一条记录~~   

7. 定位并优化慢查询Sql:  
    - 根据慢日志定位慢查询sql
    - 使用explain等工具分析sql  
    （里面会显示type和extra字段值，其中type显示index和all时常常需要调优，而extra字段中显示Using filesort时表示，MySQL没能使用索引完成操作，排序可能在内存和磁盘上进行；Using temporary则表示，使用了临时表，常见于排序order by和group by）  
    - 修改sql或者尽量让sql走索引（让SQL走索引的方法见 8.最左匹配原则）  

8. 最左匹配原则  
MySQL会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配，比如a=3 and b=4 and c>5 and d=6。以这样的条件进行查询时，联合索引只能结合a,b,c，到c处就停止了。因此，若c写在了最前面，则执行查询时，只能用到c的索引来排序。又，若，c字段没有建立索引，则会使查询无索引可用，从而导致速度下降。因此，这种情况下，要尽量让c出现在后面。（注：其它=的字段或in可以随意安排前后顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式。）  

9. MyISAM与InnoDB关于锁方面的区别  
MyISAM默认用的是表级锁，不支持行级锁。  
InnoDB默认用的是行级锁，也支持表级锁。  
（只有读锁（共享锁）之间是兼容的，写锁（排它锁）和读锁、写锁和写锁之间是冲突不兼容的。）

10. 数据库锁的分类  
    - 按锁的粒度划分，可分为表级锁、行级锁、页级锁
    - 按锁级别划分，可分为共享锁、排它锁
    - 按加锁方式划分，可分为自动锁（增删改时自动加的锁）、显式锁（查时，语句中自己加的锁）
    - 按操作划分，可分为DML锁，DDL锁（DML为数据操作时加的锁，DDL为表结构更改时加的锁）
    - 按使用方式划分，可分为乐观锁、悲观锁  

11. 当前读和快照读
当前读表示增加了锁的增删改查语句。快照读则表示未加锁的数据库操作语句返回的结果。  

12. RC、RR级别下的InnoDB的非阻塞读如何实现  
    三个因子
    - 数据行里的
    DB_TRX_ID（标识最近一次对本行数据做修改，无论是insert，update，事务的标识符，即最后一次修改本行数据的事务ID，delete在innoDB看来也是一次update操作，更新行中的一个特殊位，将行标识为deleted,也就是说数据行中除了这三列，还有一个被称为deleted的隐藏列）
    DB_ROLL_PTR（回滚指针，指写入回滚段ROLLBACK SEGMENT的undo日志记录，如果一行记录被更新，则undolockrecalled包含从建该行记录被更新之前内容所必须的信息）
    DB_ROW_ID（行号，包含一个随着新行插入而单调递增的行ID,当由innoDB自动产生具体索引时，具体索引会包括这个行id的值，否则这个行ID不会出现在任何索引中）字段
    - undo日志：当我们对记录做了变更操作时，就会产生undo记录，undo记录中存储的是老版的数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录，undolog主要分为两种insertundolog,updateundolog,其中insertundolog表示事务对insert新记录产生的undolog,只在事务回滚时需要并且在事务提交后就可能会立即丢弃。updateundolog事务对记录进行delete或者update时产生的undolog，不仅在事务回滚时需要，快照读也需要所以不能删除，只有数据库所使用的快照中不涉及该日志记录对应的回滚日志才会被删除
    - read view:主要用来做可见性判断的，即当我们做快照读select的时候会针对我们所查询的数据创建出一个read view来决定当前事务能看到的是哪个版本的数据，有可能是当前最新的数据，也有可能只允许你看undolog里面某个版本的数据，遵循可见性算法。主要是将要修改的数据的DB_TRX_ID取出来，与系统其他活跃ID做对比如果大于或者等于这些ID的话，就通过DB_ROLL_PTR指针去取出undolog上一层的DB_TRX_ID直到小于这些活跃事务的ID为止，这样就保证了我们获取的数据版本是是当前最稳定的版本

    每当我们start transaction的时候事务ID都会去递增，也就是说越新开启的事务这个ID就会越大由于生成是时机不同，造成了RC,RR两种事务隔离级别的可见性不同
    在Repeatable read隔离级别下，session Strat transaction后的第一条快照读会创建一个快照即read view ,将当前活跃的其他事务记录起来，此后再调用快照读的时候还是用的是同一个read view
    在 read committed级别下，事务中每条 select语句每次调用快照读的时候都会创建新的快照，这就是为什么我们在此隔离级别下能用快照读看到其他事务已提交的对表的增删改了，而在RR下如果首次使用快照读是在别的事务对数据进行增删改提交之前的，此后即便别的事务对数据做了增删改并提交，还是读不到数据变更的原因（首次select的时机很重要）
    由于以上的三个因子才使得innoDB在RR或者RC级别下支持非阻塞读，而读取数据时的非阻塞就是所谓的MVCC(Multi-Version Concurrency Control多版本控制)，而InnoDB的非阻塞读机制实现的仿制版的MVCC,并没有实现MVCC的核心的多版本共存，undolog中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存读不加锁，读写不冲突，在读多写少的应用中读写不冲突是非常重要的，极大的增加了系统的并发性能，快照读并非是幻读现象发生的根本，只是你如果先要提交数据变更的事务，打开read view时不论别的事务的变更是否已提交，在当前事务内再次调用快照读的时候还是读的可见性版本内的数据，有一种掩耳盗铃的意思在里面。而真正防止幻读发生的原因是事务对数据加了next-key锁。  

13. InnoDB可重复读级别下如何避免幻读  
表象： 快照读（非阻塞读）中的伪MVCC  
内在： next-key锁（行锁+gap锁）  
    - 行锁：是对单独行记录上的锁，
    - gap锁：Gap是索引树中插入新记录的空隙，而gaplock间隙锁即锁定一个范围但不包括记录本身，gap锁的目的是为了防止事务的两次当前读出现幻读的情况gap在RC隔离级别或者更低的隔离级别下是没有的，这就是RC等隔离级别无法避免幻读的原因，而在RR以及serializable级别下默认都支持gap锁  

    gap锁会用在非唯一索引或者不走索引的当前读中

14. 对主键索引或者唯一索引会用Gap锁吗？  
    - 如果where条件全部命中，则不会用Gap锁，只会加记录锁  
    - 如果where条件部分命中或者全不命中，则会加Gap锁